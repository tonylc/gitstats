<% graph_width = 800 %>

<% content_for :head do %>
<style>
  .graph-container {
    position: relative;
    margin: 2em;;
  }
  #svg-container {
    padding: 2em;
  }
  #svg-container .overlay {
    opacity: 0;
  }
  .stats-box {
    position: absolute;
    top: 2em;
    left: 3em;
    background-color: #777;
    border-radius: 3px;
    padding: 0 0.25em;
  }
  .controls {
    position: absolute;
    left: <%= graph_width + 50 %>px;
    top: 2em;
  }
  .controls ul {
    padding-left: 0;
    list-style: none;
  }
  path {
    stroke-width: 2;
    fill: none;
  }
  line {
    stroke: black;
  }
  text {
    font-family: Arial;
    font-size: 9pt;
  }
  .lang-type {
    font-weight: bold;
  }
  .axis {
    stroke: #000;
  }
</style>
<% end %>
<div class="graph-container">
  <div class="stats-box"></div>
  <div class='controls'>
    <select class='author-selector'>
      <% @author_handles.each do |handle| %>
        <option data-handle='<%= handle %>' <%= 'selected' if handle == params[:u] %>><%= handle %></option>
      <% end %>
    </select>
    <ul>
      <% @languages.each do |lang| %>
        <li><label><input class="lang-input" checked='checked' data-lang-type="<%= lang %>" type="checkbox" /><%= lang %></label>
      <% end %>
    </ul>
  </div>
  <svg id="svg-container"></svg>
</div>

<% content_for :script do %>
<%# <script src="http://d3js.org/d3.v2.min.js"></script> %>
<script src="http://d3js.org/d3.v2.js"></script>
<script>
  var rawStats = '<%= @commit_stats.values.to_json.html_safe %>';
  var rawDateStats = '<%= @commit_dates.as_json.to_json.html_safe %>';
  function getCopyOfDate(date) {
    return new Date(date.getTime());
  }
  function Chart() {
    this.w = <%= graph_width %>;
    this.h = 400;
    this.days = <%= @num_days %>;
    this.maxDate = new Date('<%= (@last_date) %>');
    <%# hardcoded for now %>
    this.colors = ['#f7977a', '#fff79a', '#c4df9b', '#7ea7d8', '#a187be'];
    this.lineStats = null;
    this.languageToCommit = {};
  }
  <%# determines the max number of lines from visible languages %>
  Chart.prototype.maxLines = function() {
    return Math.max.apply(this, $.map(this.lineStats, function(el, i) {
      return el.visible ? el.maxLines : 0;
    }));
  }
  <%# parse raw json and initializes line objects %>
  Chart.prototype.parseRawStats = function(rawStats) {
    var style = document.createElement('style');
    var self = this;
    this.lineStats = $.map(JSON.parse(rawStats), function(el, i) {
      var langType = el[0];
      style.innerHTML += '.' + langType + ' { color: ' + self.colors[i] + '; }.' + langType + ' circle { fill: ' + self.colors[i] + '; }';
      var commit = new LanguageCommits(langType, el[1]);
      self.languageToCommit[langType] = commit;
      return commit;
    });
    <%# adds custom styles %>
    document.getElementsByTagName('head')[0].appendChild(style);
  }
  <%# stats for all commits for a particular language on a given date %>
  function Stat(date, added, deleted) {
    this.date = date;
    this.added = added;
    this.deleted = deleted;
  }
  Stat.prototype.totalLines = function() {
    return this.added + this.deleted;
  }
  Stat.prototype.addToPlusCount = function(count) {
    this.added += count;
  };
  Stat.prototype.addToMinusCount = function(count) {
    this.deleted += count;
  };
  <%# all commits for a given user for a specified language %>
  var LanguageCommits = function(type, statsArr) {
    this.type = type;
    this.statsArr = statsArr;
    this.stats = $.map(new Array(chart.days), function(el, i) {
      var d = getCopyOfDate(chart.maxDate);
      d.setDate(d.getDate()-i);
      return new Stat(d,0,0);
    });
    this.maxLines = 0;
    this.visible = true;
    var self = this;
    this.initializeStats = function() {
      $.each(statsArr, function(i, el) {
        var lastDate = getCopyOfDate(chart.maxDate);
        var date = new Date(el[0]);
        var timeInMillis = lastDate.getTime() - date.getTime();
        var daysAgo = Math.floor(timeInMillis / (1000 * 60 * 60 * 24));
        self.stats[daysAgo].addToPlusCount(el[1]);
        self.stats[daysAgo].addToMinusCount(el[2]);
        // determine most lines in a day and add 10% to buffer
        if (self.stats[daysAgo].totalLines() > self.maxLines) {
          self.maxLines = Math.ceil(self.stats[daysAgo].totalLines() * 1.1);
        }
      });
    }
    this.initializeStats();
  }
  function CommitType(langType, added, deleted) {
    this.langType = langType;
    this.added = parseInt(added);
    this.deleted = parseInt(deleted);
    this.total = parseInt(added) + parseInt(deleted);
  }
  <%# all commits for a given user for a given date %>
  function CommitStat(dateStr, statsHash) {
    this.date = new Date(dateStr);
    this.statsHash = statsHash;
    this.commitTypes = [];
    var self = this;
    $.each(statsHash, function(langType, countStr) {
      self.commitTypes.push(new CommitType(langType, countStr.split(",")[0], countStr.split(",")[1]));
    });
    this.languageStr = function() {
      return $.map(this.commitTypes, function(el, i) {
        if (!chart.languageToCommit[el.langType].visible) {
          return '';
        }
        return '<span class="' + el.langType + ' lang-type">' + convertLanguageTypeToLanguageText(el.langType) + '</span>' + ": " + el.total;
      }).join(" ");
    }

    function convertLanguageTypeToLanguageText(langType) {
      switch(langType) {
        case "rb":
          return "Ruby";
        case "html":
          return "HTML";
        case "css":
          return "CSS";
        case "js":
          return "Javascript";
        default:
          return "Unknown";
      }
    }
  }

  var chart = new Chart();
  chart.parseRawStats(rawStats);
  var statsByDate = [];
  var minDate = new Date('<%= (@first_date).try(:strftime, "%Y-%m-%d") %>');
  var currentDate = getCopyOfDate(chart.maxDate);

  $.each(JSON.parse(rawDateStats), function(i, el) {
    var date = new Date(el[0]);
    statsByDate.push(new CommitStat(date, el[1]));
  });

  var svg = d3.select('svg')
    .attr('width', chart.w)
    .attr('height', chart.h);

  var margin = 10,
  y = d3.scale.linear().domain([0, chart.maxLines()]).range([0 + margin, chart.h - margin]),
  x = d3.time.scale().domain([minDate, chart.maxDate]).range([0 + margin, chart.w - margin]);

  var g = svg.append("svg:g")
      .attr("transform", "translate(0, " + (chart.h - margin) + ")");

  <%# draw grid %>
  g.selectAll("line.x")
    .data(x.ticks(10))
    .enter()
    .append("line")
    .attr("x1", x)
    .attr("x2", x)
    .attr("y1", -1 * y(0))
    .attr("y2", -1 * y(chart.maxLines()))
    .style("stroke", "#ccc");

  g.selectAll("line.y")
    .data(y.ticks(10))
    .enter()
    .append("line")
    .attr("x1", x(minDate))
    .attr("x2", x(chart.maxDate))
    .attr("y1", function(d) { return -1 * y(d); })
    .attr("y2", function(d) { return -1 * y(d); })
    .style("stroke", "#ccc");

  <%# draw the colored line %>
  var focuses = [];
  $.each(chart.lineStats, function(i, el) {
    console.log('i',i,el.type,el,chart.colors[i]);
    var line = d3.svg.line()
        .x(function(d) { return x(d.date); })
        .y(function(d) { return -1 * y(d.totalLines()); })
    var path = g.append("svg:path")
      .attr('class', 'line-' + el.type)
      .attr("d", line(el.stats.reverse()))
      .attr('stroke', function(d) { return chart.colors[i]; });
    var totalLength = path.node().getTotalLength();
    path
      .attr("stroke-dasharray", totalLength + " " + totalLength)
      .attr("stroke-dashoffset", totalLength)
      .transition()
        .duration(2000)
        .attr("stroke-dashoffset", 0);
    var focus = svg.append("g")
      .attr("class", "focus " + el.type)
      .style("display", "none")
        .append("circle")
        .attr("r", 4.5);
    focuses.push(focus);
  });

  <%# draw x-axis %>
  g.append("line")
    .attr('class', 'x axis')
    .attr("x1", x(minDate))
    .attr("y1", -1 * y(0))
    .attr("x2", x(chart.maxDate))
    .attr("y2", -1 * y(0));

  <%# draw y-axis %>
  g.append("line")
    .attr('class', 'y axis')
    .attr("x1", x(minDate))
    .attr("y1", -1 * y(0))
    .attr("x2", x(minDate))
    .attr("y2", -1 * y(chart.maxLines()));

  <%# draw labels %>
  var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom")
    .tickFormat(d3.time.format("%m/%d/%Y"))
    .ticks(d3.time.days, 10);
  svg.append("g")
    .attr("class", "x-axis")
    .attr("transform", "translate(0," + (chart.h) + ")")
    .call(xAxis);

  g.selectAll(".yLabel")
    .data(y.ticks(10))
    .enter().append("svg:text")
    .attr("class", "yLabel")
    .text(String)
    .attr('text-anchor', 'end')
    .attr("x", 0)
    .attr("y", function(d) { return -1 * y(d) })
    .attr("dy", 4);

  <%# draw transparent overlay to track mouse movements %>
  svg.append("rect")
      .attr("class", "overlay")
      .attr("width", chart.w)
      .attr("height", chart.h)
      .on("mouseover", function() { $('.focus').show(); })
      .on("mouseout", function() { $('.focus').hide(); })
      .on("mousemove", mousemove);

  var bisectDate = d3.bisector(function(d) { return d.date; }).right;

  function mousemove() {
    var x0 = x.invert(d3.mouse(this)[0]);

    $.each(chart.lineStats, function(ignored, el) {
      var i = bisectDate(el.stats, x0, 1);
      if (i >= el.stats.length) {
        return;
      }
      var d0 = el.stats[i - 1],
        d1 = el.stats[i],
        d = x0 - d0.date > d1.date - x0 ? d1 : d0;
      focuses[ignored].attr("transform", "translate(" + x(d.date) + "," + (chart.h - margin - y(d.totalLines())) + ")");
      if (ignored == 0) {
        (function(selectedDate) {
          var el;
          for (var i = 0; i < statsByDate.length; i++) {
            if (statsByDate[i].date.getTime() == selectedDate.getTime()) {
              el = statsByDate[i];
              break;
            }
          }
          if (el === undefined) {
            return;
          }
          var d = new Date(el.date.getTime());
          var curr_date = d.getDate();
          var curr_month = d.getMonth() + 1; //Months are zero based
          var dateStr = d.getFullYear() + "/" + (d.getMonth() + 1) + "/" + d.getDate();
          $('.stats-box').html(dateStr + ": " + el.languageStr());
        })(d.date);
      }
    });
  }

  $('.lang-input').on('click', function() {
    var languageType = $(this).data('lang-type');
    $('path.line-' + languageType).toggle();
    $('.focus.' + languageType + ' circle').toggle();
    chart.languageToCommit[languageType].visible = !chart.languageToCommit[languageType].visible
  });

  $('.author-selector').on('change', function() {
    window.location.href = '<%= root_path %>' + '?u=' + $(this).val();
  });

</script>
<% end %>